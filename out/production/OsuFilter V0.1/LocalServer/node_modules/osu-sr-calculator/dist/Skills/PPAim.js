"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Skill_1 = require("./Skill");
const OsuMovement_1 = require("../OsuMovement");
const Utils_1 = require("../Utils");
const PoissonBinomial_1 = require("../Objects/PoissonBinomial");
const MathNet_1 = require("../MathNet");
class PPAim extends Skill_1.Skill {
    constructor() {
        super(...arguments);
        this.SkillMultiplier = undefined;
        this.StrainDecayBase = undefined;
    }
    static CalculateAimAttributes(hitObjects, clockRate, strainHistory) {
        const movements = this.createMovements(hitObjects, clockRate, strainHistory);
        // console.log(movements);
        // console.log(movements.length);
        const fcProbTP = this.calculateFCProbTP(movements);
        const fcTimeTP = this.calculateFCTimeTP(movements);
        // graph text?
        const comboTPs = this.calculateComboTps(movements);
        const { missTPs, missCounts } = this.calculateMissTPsMissCounts(movements, fcTimeTP);
        const { cheeseLevels, cheeseFactors } = this.calculateCheeseLevelsVSCheeseFactors(movements, fcProbTP);
        const cheeseNoteCount = this.getCheeseNoteCount(movements, fcProbTP);
        const returnValue = { aimDiff: fcProbTP, fcTimeTP, comboTPs, missTPs, missCounts, cheeseNoteCount, cheeseLevels, cheeseFactors };
        // console.log('Return value:', returnValue);
        return returnValue;
    }
    static createMovements(hitObjects, clockRate, strainHistory) {
        OsuMovement_1.default.Initialize();
        const movements = [];
        if (hitObjects.length === 0)
            return movements;
        movements.push(...OsuMovement_1.default.ExtractMovementFirstObject(hitObjects[0]));
        for (let i = 1; i < hitObjects.length; i++) {
            const obj0 = i > 1 ? hitObjects[i - 2] : null;
            const obj1 = hitObjects[i - 1];
            const obj2 = hitObjects[i];
            const obj3 = i < hitObjects.length - 1 ? hitObjects[i + 1] : null;
            const tapStrain = strainHistory[i];
            movements.push(...OsuMovement_1.default.ExtractMovement(obj0, obj1, obj2, obj3, tapStrain, clockRate));
        }
        return movements;
    }
    static calculateFCProbTP(movements, cheeseLevel = this.defaultCheeseLevel) {
        const fcProbabilityTPMin = this.calculateFCProb(movements, this.tpMin, cheeseLevel);
        // console.log(`fcProbabilityTPMin: ${fcProbabilityTPMin}`);
        if (fcProbabilityTPMin >= this.probabilityThreshold)
            return this.tpMin;
        const fcProbabilityTPMax = this.calculateFCProb(movements, this.tpMax, cheeseLevel);
        // console.log(`fcProbabilityTPMax: ${fcProbabilityTPMax}`);
        if (fcProbabilityTPMax <= this.probabilityThreshold)
            return this.tpMax;
        const fcProbMinusThreshold = (tp) => this.calculateFCProb(movements, tp, cheeseLevel) - this.probabilityThreshold;
        const returnValue = MathNet_1.MathNet.FindRoot(fcProbMinusThreshold, this.tpMin, this.tpMax, this.tpPrecision).root;
        // console.log(`returnValue: ${returnValue}`);
        return returnValue;
    }
    static calculateFCTimeTP(movements) {
        if (movements.length === 0)
            return 0;
        const mapLength = movements[movements.length - 1].Time - movements[0].Time;
        const timeThreshold = this.timeThresholdBase + mapLength;
        const maxFCTime = this.calculateFCTime(movements, this.tpMin);
        if (maxFCTime <= timeThreshold)
            return this.tpMin;
        const minFCTime = this.calculateFCTime(movements, this.tpMax);
        if (minFCTime >= timeThreshold)
            return this.tpMax;
        const fcTimeMinusThreshold = (tp) => this.calculateFCTime(movements, tp) - timeThreshold;
        return MathNet_1.MathNet.FindRoot(fcTimeMinusThreshold, this.tpMin, this.tpMax, this.tpPrecision).root;
    }
    static calculateMissTPsMissCounts(movements, fcTimeTP) {
        const missTPs = Utils_1.default.initializeArray(this.difficultyCount);
        const missCounts = Utils_1.default.initializeArray(this.difficultyCount);
        const fcProb = this.calculateFCProb(movements, fcTimeTP, this.defaultCheeseLevel);
        for (let i = 0; i < this.difficultyCount; i++) {
            const missTP = fcTimeTP * (1 - Math.pow(i, 1.5) * 0.005);
            const missProbs = this.getMissProbs(movements, missTP);
            missTPs[i] = missTP;
            missCounts[i] = this.getMissCount(fcProb, missProbs);
        }
        return { missTPs, missCounts };
    }
    static getMissProbs(movements, tp) {
        const missProbs = Utils_1.default.initializeArray(movements.length);
        for (let i = 0; i < movements.length; i++) {
            const movement = movements[i];
            missProbs[i] = 1 - this.calculateCheeseHitProb(movement, tp, this.defaultCheeseLevel);
        }
        return missProbs;
    }
    static getMissCount(p, missProbabilities) {
        const distribution = new PoissonBinomial_1.PoissonBinomial(missProbabilities);
        const cdfMinusProb = (missCount) => distribution.Cdf(missCount) - p;
        return MathNet_1.MathNet.FindRootExpand(cdfMinusProb, -100, 1000).root;
    }
    static calculateCheeseLevelsVSCheeseFactors(movements, fcProbTP) {
        const cheeseLevels = Utils_1.default.initializeArray(this.cheeseLevelCount);
        const cheeseFactors = Utils_1.default.initializeArray(this.cheeseLevelCount);
        for (let i = 0; i < this.cheeseLevelCount; i++) {
            const cheeseLevel = i / (this.cheeseLevelCount - 1);
            cheeseLevels[i] = cheeseLevel;
            cheeseFactors[i] = this.calculateFCProbTP(movements, cheeseLevel) / fcProbTP;
        }
        return { cheeseLevels, cheeseFactors };
    }
    static getCheeseNoteCount(movements, tp) {
        let count = 0;
        movements.forEach(movement => {
            const cheeseness = MathNet_1.MathNet.Logistic((movement.IP12 / tp - 0.6) * 15) * movement.Cheesability;
            count += cheeseness;
        });
        return count;
    }
    static calculateComboTps(movements) {
        const ComboTPs = Utils_1.default.initializeArray(this.difficultyCount);
        for (let i = 1; i <= this.difficultyCount; i++) {
            ComboTPs[i - 1] = Infinity;
            for (let j = 0; j <= this.difficultyCount - i; j++) {
                ComboTPs[i - 1] = Math.min(ComboTPs[i - 1], this.calculateComboTPForPart(movements, i, j));
            }
        }
        return ComboTPs;
    }
    static calculateComboTPForPart(movements, i, j) {
        const start = movements.length * j / this.difficultyCount;
        const end = movements.length * (j + i) / this.difficultyCount - 1;
        const partTP = this.calculateFCTimeTP(movements.slice(start, start + (end - start + 1)));
        return partTP;
    }
    static calculateFCProb(movements, tp, cheeseLevel) {
        let fcProb = 1;
        movements.forEach(movement => {
            const hitProb = this.calculateCheeseHitProb(movement, tp, cheeseLevel);
            // console.log(`hitProb: ${hitProb}`);
            fcProb *= hitProb;
        });
        return fcProb;
    }
    static calculateFCTime(movements, tp, cheeseLevel = this.defaultCheeseLevel) {
        let fcTime = 0;
        movements.forEach(movement => {
            const hitProb = this.calculateCheeseHitProb(movement, tp, cheeseLevel);
            fcTime = (fcTime + movement.RawMT) / (hitProb + 1e-10);
        });
        return fcTime;
    }
    static calculateCheeseHitProb(movement, tp, cheeseLevel) {
        let perMovementCheeseLevel = cheeseLevel;
        if (movement.EndsOnSlider)
            perMovementCheeseLevel = 1;
        const cheeseMT = movement.MT * (1 + perMovementCheeseLevel * movement.CheesableRatio);
        // console.log('movement:', movement);
        const returnValue = MathNet_1.MathNet.CalculateHitProb(movement.D, cheeseMT, tp);
        // console.log('return hitprob:', returnValue);
        return returnValue;
    }
    strainValueOf(current) {
        return undefined;
    }
}
PPAim.probabilityThreshold = 0.02;
PPAim.timeThresholdBase = 3600;
PPAim.tpMin = 0.1;
PPAim.tpMax = 100;
PPAim.tpPrecision = 1e-8;
PPAim.defaultCheeseLevel = 0.3;
PPAim.cheeseLevelCount = 11;
PPAim.difficultyCount = 20;
exports.default = PPAim;
