"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("./Utils");
const mathfn = require('mathfn');
class MathNet {
    static Logistic(x) {
        return 1 / (1 + Math.pow(Math.E, -x));
    }
    static CalculateIP(relativeD, mt) {
        return (Math.log(relativeD + 1) / Math.log(2)) / (mt + 1e-10);
    }
    static CalculateHitProb(d, mt, tp) {
        if (d === 0)
            return 1;
        if (mt * tp > 100)
            return 1;
        if (mt <= 0.03)
            return 0.03;
        // console.log('d:', d);
        // console.log('mt:', mt);
        // console.log('tp:', tp);
        const returnValue = mathfn.erf(2.066 / d * (Math.pow(2, (mt * tp)) - 1) / Math.sqrt(2));
        // console.log('erg result:', returnValue);
        return returnValue;
    }
    static FindRootExpand(f, guessLowerBound, guessUpperBound, accuracy = 1e-8, maxIterations = 100, expandFactor = 1.6, maxExpandIterations = 100) {
        MathNet.ExpandReduce(f, { lowerBound: guessLowerBound, upperBound: guessUpperBound }, expandFactor, maxExpandIterations, maxExpandIterations * 10);
        return this.FindRoot(f, guessLowerBound, guessUpperBound, accuracy, maxIterations);
    }
    static FindRoot(f, lowerBound, upperBound, accuracy, maxIterations = 100) {
        let fmin = f(lowerBound);
        let fmax = f(upperBound);
        let froot = fmax;
        let d = 0;
        let e = 0;
        let root = upperBound;
        let xMid = NaN;
        if (Math.sign(fmin) === Math.sign(fmax))
            return { root, found: false };
        for (let i = 0; i <= maxIterations; i++) {
            if (Math.sign(froot) === Math.sign(fmax)) {
                upperBound = lowerBound;
                fmax = fmin;
                e = d = root - lowerBound;
            }
            if (Math.abs(fmax) < Math.abs(froot)) {
                lowerBound = root;
                root = upperBound;
                upperBound = lowerBound;
                fmin = froot;
                froot = fmax;
                fmax = fmin;
            }
            const veryPreciseDouble = 2.2204460492503131e-16;
            const xAcc1 = veryPreciseDouble * Math.abs(root) + 0.5 * accuracy;
            let xMidOld = xMid;
            xMid = (upperBound - root) / 2;
            if (Math.abs(xMid) <= xAcc1 || this.AlmostEqualNormRelative(froot, 0, froot, accuracy))
                return { root, found: true };
            if (xMid === xMidOld)
                return { root, found: false };
            if (Math.abs(e) >= xAcc1 && Math.abs(fmin) > Math.abs(froot)) {
                const s = froot / fmin;
                let p;
                let q;
                if (this.AlmostEqualRelative(lowerBound, upperBound)) {
                    p = 2 * xMid * s;
                    q = 1 - s;
                }
                else {
                    q = fmin / fmax;
                    const r = froot / fmax;
                    p = s * (2 * xMid * q * (q - r) - (root - lowerBound) * (r - 1));
                    q = (q - 1) * (r - 1) * (s - 1);
                }
                if (p > 0)
                    q = -q;
                p = Math.abs(p);
                if (2 * p < Math.min(3 * xMid * q - Math.abs(xAcc1 * q), Math.abs(e * q))) {
                    e = d;
                    d = p / q;
                }
                else {
                    d = xMid;
                    e = d;
                }
            }
            else {
                d = xMid;
                e = d;
            }
            lowerBound = root;
            fmin = froot;
            if (Math.abs(d) > xAcc1)
                root += d;
            else
                root += this.Sign(xAcc1, xMid);
            froot = f(root);
        }
        return { root, found: false };
    }
    static AlmostEqualNormRelative(a, b, diff, maximumError) {
        const DoublePrecision = 1.1102230246251565e-16;
        if (Math.abs(a) === Infinity || Math.abs(b) === Infinity)
            return a === b;
        if (isNaN(a) || isNaN(b))
            return false;
        if (Math.abs(a) < DoublePrecision || Math.abs(b) < DoublePrecision)
            return Math.abs(diff) < maximumError;
        if ((a === 0 && Math.abs(b) < maximumError) || (b === 0 && Math.abs(a) < maximumError))
            return true;
        return Math.abs(diff) < maximumError * Math.max(Math.abs(a), Math.abs(b));
    }
    static AlmostEqualRelative(a, b) {
        const DoublePrecision = 1.1102230246251565e-16;
        return this.AlmostEqualNormRelative(a, b, a - b, DoublePrecision * 10);
    }
    static Sign(a, b) {
        return b >= 0 ? (a >= 0 ? a : -a) : (a >= 0 ? -a : a);
    }
    static Expand(f, bounds, factor = 1.6, maxIterations = 50) {
        const originalLowerBound = bounds.lowerBound;
        const originalUpperBound = bounds.upperBound;
        if (bounds.lowerBound >= bounds.upperBound)
            throw new Error('MathNet Expand: Argument out of range!');
        let fmin = f(bounds.lowerBound);
        let fmax = f(bounds.upperBound);
        for (let i = 0; i < maxIterations; i++) {
            if (Math.sign(fmin) !== Math.sign(fmax))
                return true;
            if (Math.abs(fmin) < Math.abs(fmax)) {
                bounds.lowerBound += (factor * (bounds.lowerBound - bounds.upperBound));
                fmin = f(bounds.lowerBound);
            }
            else {
                bounds.upperBound += (factor * (bounds.upperBound - bounds.lowerBound));
                fmax = f(bounds.upperBound);
            }
        }
        bounds.lowerBound = originalLowerBound;
        bounds.upperBound = originalUpperBound;
        return false;
    }
    static Reduce(f, bounds, subdivisions = 1000) {
        const originalLowerBound = bounds.lowerBound;
        const originalUpperBound = bounds.upperBound;
        if (bounds.lowerBound >= bounds.upperBound)
            throw new Error('MathNet Expand: Argument out of range!');
        let fmin = f(bounds.lowerBound);
        let fmax = f(bounds.upperBound);
        if (Math.sign(fmin) !== Math.sign(fmax))
            return true;
        const subdiv = (bounds.upperBound - bounds.lowerBound) / subdivisions;
        let smin = bounds.lowerBound;
        const sign = Math.sign(fmin);
        for (let k = 0; k < subdivisions; k++) {
            const smax = smin + subdiv;
            const sfmax = f(smax);
            if (Math.abs(sfmax) === Infinity) {
                smin = smax;
                continue;
            }
            if (Math.sign(sfmax) !== sign) {
                bounds.lowerBound = smin;
                bounds.upperBound = smax;
                return true;
            }
            smin = smax;
        }
        bounds.lowerBound = originalLowerBound;
        bounds.upperBound = originalUpperBound;
        return false;
    }
    static ExpandReduce(f, bounds, expansionFactor = 1.6, expansionMaxIterations = 50, reduceSubdivisions = 100) {
        return MathNet.Expand(f, bounds, expansionFactor, expansionMaxIterations) || MathNet.Reduce(f, bounds, reduceSubdivisions);
    }
    static LinearSpaced(length, start, stop) {
        if (length < 0)
            throw new Error('MathNet LinearSpaced: length less than 0!');
        if (length === 0)
            return [0];
        if (length === 1)
            return [stop];
        const step = (stop - start) / (length - 1);
        const data = Utils_1.default.initializeArray(length);
        for (let i = 0; i < data.length; i++) {
            data[i] = start + i * step;
        }
        data[data.length - 1] = stop;
        return data;
    }
}
exports.MathNet = MathNet;
