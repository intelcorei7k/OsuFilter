"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LinearSpline_1 = require("./Objects/LinearSpline");
const Utils_1 = require("./Utils");
const Vector_1 = require("./Objects/Vector");
const Spinner_1 = require("./Objects/osu!/HitObjects/Spinner");
const Slider_1 = require("./Objects/osu!/HitObjects/Slider");
const CubicSpline_1 = require("./Objects/CubicSpline");
const MathNet_1 = require("./MathNet");
class OsuMovement {
    static Initialize() {
        this.prepareInterp(this.ds0f, this.ks0f, this.scales0f, this.coeffs0f, 'k0fInterp', 'scale0fInterp', 'coeffs0fInterps');
        this.prepareInterp(this.ds0s, this.ks0s, this.scales0s, this.coeffs0s, 'k0sInterp', 'scale0sInterp', 'coeffs0sInterps');
        this.prepareInterp(this.ds3f, this.ks3f, this.scales3f, this.coeffs3f, 'k3fInterp', 'scale3fInterp', 'coeffs3fInterps');
        this.prepareInterp(this.ds3s, this.ks3s, this.scales3s, this.coeffs3s, 'k3sInterp', 'scale3sInterp', 'coeffs3sInterps');
    }
    static ExtractMovementFirstObject(obj) {
        const movement = this.GetEmptyMovement(obj.StartTime / 1000);
        const movementWithNested = [movement];
        if (obj instanceof Slider_1.Slider) {
            const extraNestedCount = obj.NestedHitObjects.length - 1;
            for (let i = 0; i < extraNestedCount; i++) {
                movementWithNested.push(this.GetEmptyMovement(movement.Time));
            }
        }
        return movementWithNested;
    }
    static ExtractMovement(obj0, obj1, obj2, obj3, tapStrain, clockRate) {
        // console.log('--------------------------------------------------------------------------');
        const movement = new OsuMovement();
        const t12 = (obj2.StartTime - obj1.StartTime) / clockRate / 1000;
        movement.RawMT = t12;
        movement.Time = obj2.StartTime / 1000;
        if (obj2 instanceof Spinner_1.Spinner || obj1 instanceof Spinner_1.Spinner) {
            movement.IP12 = 0;
            movement.D = 0;
            movement.MT = 1;
            movement.Cheesability = 0;
            movement.CheesableRatio = 0;
            return [movement];
        }
        if (obj0 instanceof Spinner_1.Spinner)
            obj0 = null;
        if (obj3 instanceof Spinner_1.Spinner)
            obj3 = null;
        if (obj2 instanceof Slider_1.Slider)
            movement.EndsOnSlider = true;
        const pos1 = new Vector_1.Vector([obj1.Position.x, obj1.Position.y]);
        const pos2 = new Vector_1.Vector([obj2.Position.x, obj2.Position.y]);
        const s12 = pos2.subtract(pos1).divide(2 * obj2.Radius);
        const d12 = s12.L2Norm();
        const IP12 = MathNet_1.MathNet.CalculateIP(d12, t12);
        movement.IP12 = IP12;
        let pos0 = new Vector_1.Vector([null, null]);
        let pos3 = new Vector_1.Vector([null, null]);
        let s01 = new Vector_1.Vector([null, null]);
        let s23 = new Vector_1.Vector([null, null]);
        let d01 = 0;
        let d23 = 0;
        let t01 = 0;
        let t23 = 0;
        let flowiness012 = 0;
        let flowiness123 = 0;
        let obj1InTheMiddle = false;
        let obj2InTheMiddle = false;
        // Correction #1
        let correction0 = 0;
        if (obj0 !== null) {
            pos0 = new Vector_1.Vector([obj0.Position.x, obj0.Position.y]);
            s01 = pos1.subtract(pos0).divide(2 * obj2.Radius);
            d01 = s01.L2Norm();
            t01 = (obj1.StartTime - obj0.StartTime) / clockRate / 1000;
            if (d12 !== 0) {
                const tRatio0 = t12 / t01;
                if (tRatio0 > this.tRatioThreshold) {
                    if (d01 === 0)
                        correction0 = this.correction0Still;
                    else {
                        const cos012 = Math.min(Math.max(s01.negate().DotProduct(s12) / d01 / d12, -1), 1);
                        // console.log('s12:', s12);
                        // console.log('s01:', s01.negate().DotProduct(s12));
                        const correction0_moving = this.correction0MovingSpline.Interpolate(cos012);
                        const movingness = MathNet_1.MathNet.Logistic(d01 * 2) * 2 - 1;
                        correction0 = (movingness * correction0_moving + (1 - movingness) * this.correction0Still) * 1.5;
                    }
                    // console.log('1:', correction0);
                }
                else if (tRatio0 < 1 / this.tRatioThreshold) {
                    if (d01 === 0)
                        correction0 = 0;
                    else {
                        const cos012 = Math.min(Math.max(s01.negate().DotProduct(s12) / d01 / d12, -1), 1);
                        correction0 = (1 - cos012) * MathNet_1.MathNet.Logistic((d01 * tRatio0 - 1.5) * 4) * 0.3;
                    }
                    // console.log('2:', correction0);
                }
                else {
                    obj1InTheMiddle = true;
                    const normalized_pos0 = s01.negate().divide(t01).multiply(t12);
                    // console.log(`normalized_pos0: ${normalized_pos0.values}`);
                    const x0 = normalized_pos0.DotProduct(s12) / d12;
                    // console.log(`x0: ${x0}`);
                    const y0 = (normalized_pos0.subtract(s12.multiply(x0).divide(d12))).L2Norm();
                    // console.log(`y0: ${y0}`);
                    const correction0Flow = this.calcCorrection0or3(d12, x0, y0, this.k0fInterp, this.scale0fInterp, this.coeffs0fInterps);
                    const correction0Snap = this.calcCorrection0or3(d12, x0, y0, this.k0sInterp, this.scale0sInterp, this.coeffs0sInterps);
                    const correction0Stop = this.calcCorrection0Stop(d12, x0, y0);
                    // console.log(`correction0Flow: ${correction0Flow}`);
                    // console.log(`correction0Snap: ${correction0Snap}`);
                    // console.log(`correction0Stop: ${correction0Stop}`);
                    flowiness012 = MathNet_1.MathNet.Logistic((correction0Snap - correction0Flow - 0.05) * 20);
                    // console.log(`flowiness012: ${flowiness012}`);
                    correction0 = Utils_1.default.PowerMean([correction0Flow, correction0Snap, correction0Stop], -10) * 1.3;
                    // console.log('3:', correction0);
                }
            }
        }
        // Correction #2
        let correction3 = 0;
        if (obj3 !== null) {
            pos3 = new Vector_1.Vector([obj3.Position.x, obj3.Position.y]);
            s23 = pos3.subtract(pos2).divide(2 * obj2.Radius);
            d23 = s23.L2Norm();
            t23 = (obj3.StartTime - obj2.StartTime) / clockRate / 1000;
            if (d12 !== 0) {
                const tRatio3 = t12 / t23;
                if (tRatio3 > this.tRatioThreshold) {
                    if (d23 === 0)
                        correction3 = 0;
                    else {
                        const cos123 = Math.min(Math.max(s12.negate().DotProduct(s23) / d12 / d23, -1), 1);
                        const correction3_moving = this.correction0MovingSpline.Interpolate(cos123);
                        const movingness = MathNet_1.MathNet.Logistic(d23 * 6 - 5) - MathNet_1.MathNet.Logistic(-5);
                        correction3 = (movingness * correction3_moving) * 0.5;
                        // console.log(this.correction0MovingSpline.getValues());
                        // console.log(`cos123: ${cos123}; movingness: ${movingness}; correction3_moving: ${correction3_moving}`);
                    }
                }
                else if (tRatio3 < 1 / this.tRatioThreshold) {
                    if (d23 === 0)
                        correction3 = 0;
                    else {
                        const cos123 = Math.min(Math.max(s12.negate().DotProduct(s23) / d12 / d23, -1), 1);
                        correction3 = (1 - cos123) * MathNet_1.MathNet.Logistic((d23 * tRatio3 - 1.5) * 4) * 0.15;
                        // console.log(`cos123: ${cos123}`);
                    }
                }
                else {
                    obj2InTheMiddle = true;
                    const normalizedPos3 = s23.divide(t23).multiply(t12);
                    const x3 = normalizedPos3.DotProduct(s12) / d12;
                    const y3 = (normalizedPos3.subtract(s12.multiply(x3).divide(d12))).L2Norm();
                    const correction3Flow = this.calcCorrection0or3(d12, x3, y3, this.k3fInterp, this.scale3fInterp, this.coeffs3fInterps);
                    const correction3Snap = this.calcCorrection0or3(d12, x3, y3, this.k3sInterp, this.scale3sInterp, this.coeffs3sInterps);
                    flowiness123 = MathNet_1.MathNet.Logistic((correction3Snap - correction3Flow - 0.05) * 20);
                    correction3 = Math.max(Utils_1.default.PowerMeanValues(correction3Flow, correction3Snap, -10) - 0.1, 0) * 0.5;
                    // console.log(`correction3flow: ${correction3Flow}; correction3snap: ${correction3Snap}`);
                }
            }
        }
        // Correction #3
        let patternCorrection = 0;
        if (obj1InTheMiddle && obj2InTheMiddle) {
            const gap = (s12.subtract(s23.divide(2)).subtract(s01.divide(2))).L2Norm() / (d12 + 0.1);
            patternCorrection = (MathNet_1.MathNet.Logistic((gap - 0.75) * 8) - MathNet_1.MathNet.Logistic(-6)) *
                MathNet_1.MathNet.Logistic((d01 - 0.7) * 10) * MathNet_1.MathNet.Logistic((d23 - 0.7) * 10) *
                Utils_1.default.PowerMeanValues(flowiness012, flowiness123, 2) * 0.6;
        }
        // Correction #4
        let tapCorrection = 0;
        if (d12 > 0 && tapStrain !== null) {
            // console.log('result:', tapStrain.values);
            tapCorrection = MathNet_1.MathNet.Logistic((Utils_1.default.PowerMean(tapStrain.values, 2) / IP12 - 1.34) / 0.1) * 0.3;
        }
        // Correction #5
        let timeEarly = 0;
        let timeLate = 0;
        let cheesabilityEarly = 0;
        let cheesabilityLate = 0;
        if (d12 > 0) {
            let t01Reciprocal;
            let ip01;
            if (obj0 !== null) {
                t01Reciprocal = 1 / (t01 + 1e-10);
                ip01 = MathNet_1.MathNet.CalculateIP(d01, t01);
            }
            else {
                t01Reciprocal = 0;
                ip01 = 0;
            }
            cheesabilityEarly = MathNet_1.MathNet.Logistic((ip01 / IP12 - 0.6) * (-15)) * 0.5;
            timeEarly = cheesabilityEarly * (1 / (1 / (t12 + 0.07) + t01Reciprocal));
            let t23Reciprocal;
            let ip23;
            if (obj3 !== null) {
                t23Reciprocal = 1 / (t23 + 1e-10);
                ip23 = MathNet_1.MathNet.CalculateIP(d23, t23);
            }
            else {
                t23Reciprocal = 0;
                ip23 = 0;
            }
            cheesabilityLate = MathNet_1.MathNet.Logistic((ip23 / IP12 - 0.6) * (-15)) * 0.5;
            timeLate = cheesabilityLate * (1 / (1 / (t12 + 0.07) + t23Reciprocal));
        }
        // Correction #6
        const smallCircleBonus = MathNet_1.MathNet.Logistic((55 - 2 * obj2.Radius) / 3) * 0.3;
        // Correction #7
        const stackedThreshold = 0.8;
        let d12StackedNerf;
        if (d12 < stackedThreshold)
            d12StackedNerf = Math.max(1.4 * (d12 - stackedThreshold) + stackedThreshold, 0);
        else
            d12StackedNerf = d12;
        // Correction #8
        if (obj0 !== null && obj3 !== null) {
            const d02 = (pos2.subtract(pos0).divide(2 * obj2.Radius)).L2Norm();
            const d13 = (pos3.subtract(pos1).divide(2 * obj2.Radius)).L2Norm();
            const d03 = (pos3.subtract(pos0).divide(2 * obj2.Radius)).L2Norm();
            if (d01 < 1 && d02 < 1 && d03 < 1 && d12 < 1 && d13 < 1 && d23 < 1) {
                correction0 = 0;
                correction3 = 0;
                patternCorrection = 0;
                tapCorrection = 0;
            }
        }
        // Apply corrections
        const d12WithCorrection = d12StackedNerf * (1 + smallCircleBonus) * (1 + correction0 + correction3 + patternCorrection) * (1 + tapCorrection);
        // console.log(`d12StackedNerf: ${d12StackedNerf}; smallCircleBonus: ${smallCircleBonus}, correction0: ${correction0}, correction3: ${correction3}, patternCorrection: ${patternCorrection}, tapCorrection: ${tapCorrection}`);
        movement.D = d12WithCorrection;
        movement.MT = t12;
        movement.Cheesability = cheesabilityEarly + cheesabilityLate;
        movement.CheesableRatio = (timeEarly + timeLate) / (t12 + 1e-10);
        const movementWithNested = [movement];
        if (obj2.NestedHitObjects !== undefined) {
            const extraNestedCount = obj2.NestedHitObjects.length - 1;
            for (let i = 0; i < extraNestedCount; i++) {
                movementWithNested.push(this.GetEmptyMovement(movement.Time));
            }
        }
        return movementWithNested;
    }
    static GetEmptyMovement(time) {
        const osuMovement = new OsuMovement();
        osuMovement.D = 0;
        osuMovement.MT = 1;
        osuMovement.CheesableRatio = 0;
        osuMovement.Cheesability = 0;
        osuMovement.RawMT = 0;
        osuMovement.IP12 = 0;
        osuMovement.Time = time;
        return osuMovement;
    }
    static prepareInterp(ds, ks, scales, coeffs, kInterp, scaleInterp, coeffsInterps) {
        this[kInterp] = LinearSpline_1.LinearSpline.InterpolateSorted(ds, ks);
        this[scaleInterp] = LinearSpline_1.LinearSpline.InterpolateSorted(ds, scales);
        const secondDimension = Utils_1.default.initializeArray(this.numCoeffs);
        this[coeffsInterps] = Utils_1.default.initializeArray(coeffs.length, secondDimension);
        for (let i = 0; i < coeffs.length; i++) {
            for (let j = 0; j < this.numCoeffs; j++) {
                const coeff_ij = Utils_1.default.initializeArray(coeffs[0][0].length);
                for (let k = 0; k < coeffs[0][0].length; k++) {
                    coeff_ij[k] = coeffs[i][j][k];
                }
                // console.log(i, j, coeff_ij);
                const linearSpline = LinearSpline_1.LinearSpline.InterpolateSorted(ds, coeff_ij);
                // console.log(linearSpline);
                this[coeffsInterps][i][j] = LinearSpline_1.LinearSpline.InterpolateSorted(ds, coeff_ij);
                // console.log(this[coeffsInterps][0]);
            }
        }
        // console.log(coeffsInterps);
        // console.log(this[coeffsInterps][0]);
    }
    static calcCorrection0or3(d, x, y, kInterp, scaleInterp, coeffsInterps) {
        let correction_raw = kInterp.Interpolate(d);
        // for (let i = 0; i < coeffsInterps.length; i++) {
        //     for (let j = 0; j < coeffsInterps[i].length; j++) {
        //         console.log(i, j, coeffsInterps[i][j]);
        //     }
        // }
        // console.log(`correction_raw: ${correction_raw}`);
        for (let i = 0; i < coeffsInterps.length; i++) {
            const cs = Utils_1.default.initializeArray(this.numCoeffs);
            for (let j = 0; j < this.numCoeffs; j++) {
                cs[j] = coeffsInterps[i][j].Interpolate(d);
            }
            correction_raw += (cs[3] * Math.sqrt(Math.pow((x - cs[0]), 2) + Math.pow((y - cs[1]), 2) + cs[2]));
            // console.log(`${i}: ${correction_raw}`);
        }
        return MathNet_1.MathNet.Logistic(correction_raw) * scaleInterp.Interpolate(d);
    }
    static calcCorrection0Stop(d, x, y) {
        return MathNet_1.MathNet.Logistic(10 * Math.sqrt(x * x + y * y + 1) - 12);
    }
}
OsuMovement.correction0MovingSpline = CubicSpline_1.CubicSpline.InterpolateHermiteSorted([-1, -0.6, 0.3, 0.5, 1], [1, 1, 0.85, 0.6, 0], [0, 0, -0.8, -2, -0.8]);
OsuMovement.numCoeffs = 4;
OsuMovement.ds0f = [0, 1, 1.7, 2.3];
OsuMovement.ks0f = [-14.4, -9.5, -7.3, -2];
OsuMovement.scales0f = [1, 1, 1, 1];
OsuMovement.coeffs0f = [
    [
        [0, -1, -1.7, -2],
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [6, 3, 1.3, 1]
    ],
    [
        [0, -0.5, -0.85, -1],
        [0, 1, 1.7, 2],
        [1, 1, 1, 1],
        [3, 1.5, 1, 1]
    ],
    [
        [0, -0.5, -0.85, -1],
        [0, -1, -1.7, -2],
        [1, 1, 1, 1],
        [3, 1.5, 1, 1]
    ]
];
OsuMovement.ds0s = [0, 1.5, 2.5, 4, 6, 8];
OsuMovement.ks0s = [-1, -1.8, -5.8, -5.8, -4, -4];
OsuMovement.scales0s = [1, 0.85, 0.6, 1, 1, 1];
OsuMovement.coeffs0s = [
    [
        [0.5, 2, 2.8, 4, 6, 6],
        [0, 0, 0, 0, 0, 0],
        [1, 1, 1, 0, 0, 0],
        [0.6, 0.6, 0.8, 0.6, 0.4, 0.4]
    ],
    [
        [0.25, 1, 1.4, 2, 3, 3],
        [0.5, 2, 2.8, 4, 6, 6],
        [1, 1, 1, 1, 1, 1],
        [0.6, 0.6, 0.8, 0.6, 0.16, 0.16]
    ],
    [
        [0.25, 1, 1.4, 2, 3, 3],
        [-0.5, -2, -2.8, -4, -6, -6],
        [1, 1, 1, 1, 1, 1],
        [0.6, 0.6, 0.8, 0.6, 0.16, 0.16]
    ],
    [
        [0, 0, 0, -1, -1.5, -1.5],
        [0, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1],
        [-0.7, -0.7, -1.1, -0.8, -0.16, -0.16]
    ]
];
OsuMovement.ds3f = [0, 1, 2, 3, 4];
OsuMovement.ks3f = [-4, -4, -4.5, -2.5, -2.5];
OsuMovement.scales3f = [1, 1, 1, 1, 1];
OsuMovement.coeffs3f = [
    [
        [0, 1, 2, 4, 4],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [1.5, 1.5, 1, 0, 0]
    ],
    [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [2, 2, 2.5, 3.5, 3.5]
    ]
];
OsuMovement.ds3s = [1, 1.5, 2.5, 4, 6, 8];
OsuMovement.ks3s = [-2, -2, -3, -5.4, -4.9, -4.9];
OsuMovement.scales3s = [1, 1, 1, 1, 1, 1];
OsuMovement.coeffs3s = [
    [
        [-2, -2, -3, -4, -6, -6],
        [0, 0, 0, 0, 0, 0],
        [1, 1, 1, 0, 0, 0],
        [0.4, 0.4, 0.2, 0.4, 0.3, 0.3]
    ],
    [
        [-1, -1, -1.5, -2, -3, -3],
        [1.4, 1.4, 2.1, 2, 3, 3],
        [1, 1, 1, 1, 1, 1],
        [0.4, 0.4, 0.2, 0.4, 0.2, 0.2]
    ],
    [
        [-1, -1, -1.5, -2, -3, -3],
        [-1.4, -1.4, -2.1, -2, -3, -3],
        [1, 1, 1, 1, 1, 1],
        [0.4, 0.4, 0.2, 0.4, 0.2, 0.2]
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0.6, 0.6, 0.6]
    ],
    [
        [1, 1, 1.5, 2, 3, 3],
        [0, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1],
        [0, 0, -0.6, -0.4, -0.3, -0.3]
    ]
];
OsuMovement.tRatioThreshold = 1.4;
OsuMovement.correction0Still = 0;
exports.default = OsuMovement;
