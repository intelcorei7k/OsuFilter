"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("../Utils");
class LinearSpline {
    // private readonly _indefiniteIntegral: number[];
    constructor(x, c0, c1) {
        if ((x.length !== c0.length + 1 && x.length !== c0.length) || x.length !== c1.length + 1)
            throw new Error('LinearSpline: argument vectors same length');
        if (x.length < 2)
            throw new Error('LinearSpline: array x too small');
        this._x = x;
        this._c0 = c0;
        this._c1 = c1;
        // this._indefiniteIntegral = this.ComputeIndefiniteIntegral();
    }
    getValues() {
        return [this._x, this._c0, this._c1];
    }
    static InterpolateSorted(x, y) {
        if (x.length !== y.length)
            throw new Error('LinearSpline InterpolateSorted: arguments same length');
        if (x.length < 2)
            throw new Error('LinearSpline InterpolateSorted: array x too small');
        const c1 = Utils_1.default.initializeArray(x.length - 1);
        for (let i = 0; i < c1.length; i++) {
            c1[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
        }
        return new LinearSpline(x, y, c1);
    }
    Interpolate(t) {
        const k = this.LeftSegmentIndex(t);
        return this._c0[k] + (t - this._x[k]) * this._c1[k];
    }
    // private ComputeIndefiniteIntegral(): number[] {
    //     const integral = Utils.initializeArray(this._c1.length);
    //     for (let i = 0; i < integral.length - 1; i++) {
    //         const w = this._x[i + 1] - this._x[i];
    //         integral[i + 1] = integral[i] + w * (this._c0[i] + w * this._c1[i] / 2);
    //     }
    //     return integral;
    // }
    LeftSegmentIndex(t) {
        let index;
        for (let i = 0; i < this._x.length; i++) {
            const value = this._x[i];
            if (value === t) {
                index = i;
                break;
            }
            if (value > t) {
                index = ~i;
                break;
            }
        }
        if (index === undefined)
            index = ~this._x.length;
        if (index < 0)
            index = ~index - 1;
        return Math.min(Math.max(index, 0), this._x.length - 2);
    }
}
exports.LinearSpline = LinearSpline;
