"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vector_1 = require("../Objects/Vector");
const Utils_1 = require("../Utils");
const MathNet_1 = require("../MathNet");
class Tap {
    // private static decayCoeffs: Vector = new Vector([2.3, 0.7, -0.8, -2.2].map(v => Math.pow(Math.E, v)));
    static CalculateTapAttributes(hitObjects, clockRate) {
        const { strainHistory, tapDiff } = this.calculateTapStrain(hitObjects, 0, clockRate);
        const burstStrain = strainHistory.reduce((total, current) => {
            if (current.getValue(0) > total)
                return current.getValue(0);
            else
                return total;
        }, -Infinity);
        const streamnessMask = this.CalculateStreamnessMask(hitObjects, burstStrain, clockRate);
        const streamNoteCount = streamnessMask.reduce((total, current) => total + current, 0);
        const { mashLevels, tapSkills } = this.calculateMashLevelsVSTapSkills(hitObjects, clockRate);
        const returnValue = { tapDiff, streamNoteCount, mashLevels, tapSkills, strainHistory };
        return returnValue;
    }
    static calculateTapStrain(hitObjects, mashLevel, clockRate) {
        let prevPrevTime = hitObjects[0].StartTime / 1000;
        let prevTime = hitObjects[1].StartTime / 1000;
        const strainHistory = [this.decayCoeffs.multiply(0), this.decayCoeffs.multiply(0)];
        let currStrain = this.decayCoeffs.multiply(1);
        for (let i = 2; i < hitObjects.length; i++) {
            const currTime = hitObjects[i].StartTime / 1000;
            currStrain = currStrain.PointwiseMultiply((this.decayCoeffs.negate().multiply(currTime - prevTime).divide(clockRate)).PointwiseExp());
            strainHistory.push(currStrain.PointwisePower(1.1 / 3).multiply(1.5));
            const relativeD = hitObjects[i].Position.subtract(hitObjects[i - 1].Position).length() / (2 * hitObjects[i].Radius);
            const spacedBuff = this.calculateSpacedness(relativeD) * this.spacedBuffFactor;
            const deltaTime = Math.max((currTime - prevPrevTime) / clockRate, 0.01);
            const currStrainBase = Math.max(Math.pow(deltaTime, -2.7) * 0.265, Math.pow(deltaTime, -2));
            currStrain = currStrain.add(this.decayCoeffs.multiply(currStrainBase * Math.pow(this.calculateMashNerfFactor(relativeD, mashLevel), 3) * Math.pow(1 + spacedBuff, 3)));
            prevPrevTime = prevTime;
            prevTime = currTime;
        }
        const strainResult = this.decayCoeffs.multiply(0);
        for (let j = 0; j < this.decayCoeffs.Count(); j++) {
            let singleStrainHistory = Utils_1.default.initializeArray(hitObjects.length);
            for (let i = 0; i < hitObjects.length; i++) {
                singleStrainHistory[i] = strainHistory[i].getValue(j);
            }
            singleStrainHistory = singleStrainHistory.sort((a, b) => a - b);
            singleStrainHistory = singleStrainHistory.reverse();
            let singleStrainResult = 0;
            const k = 1 - 0.04 * Math.sqrt(this.decayCoeffs.getValue(j));
            for (let i = 0; i < hitObjects.length; i++) {
                singleStrainResult += singleStrainHistory[i] * Math.pow(k, i);
            }
            strainResult.setValue(j, singleStrainResult * (1 - k));
        }
        const diff = Utils_1.default.PowerMean(strainResult.values, 2);
        return { strainHistory, tapDiff: diff };
    }
    static CalculateStreamnessMask(hitObjects, skill, clockRate) {
        const streamnessMask = [];
        streamnessMask.push(0);
        const streamTimeThreshold = Math.pow(skill, -2.7 / 3.2);
        for (let i = 1; i < hitObjects.length; i++) {
            const t = (hitObjects[i].StartTime - hitObjects[i - 1].StartTime) / 1000 / clockRate;
            streamnessMask[i] = 1 - MathNet_1.MathNet.Logistic((t / streamTimeThreshold - 1) * 15);
        }
        return streamnessMask;
    }
    static calculateMashLevelsVSTapSkills(hitObjects, clockRate) {
        const mashLevels = [];
        const tapSkills = [];
        for (let i = 0; i < this.mashLevelCount; i++) {
            const mashLevel = i / (this.mashLevelCount - 1);
            mashLevels[i] = mashLevel;
            const { strainHistory, tapDiff } = this.calculateTapStrain(hitObjects, mashLevel, clockRate);
            tapSkills[i] = tapDiff;
        }
        return { mashLevels, tapSkills };
    }
    static calculateMashNerfFactor(relativeD, mashLevel) {
        const fullMashFactor = 0.73 + 0.27 * MathNet_1.MathNet.Logistic(relativeD * 7 - 6);
        return mashLevel * fullMashFactor + (1 - mashLevel);
    }
    static calculateSpacedness(d) {
        return MathNet_1.MathNet.Logistic((d - 0.5) * 10) - MathNet_1.MathNet.Logistic(-5);
    }
}
Tap.mashLevelCount = 11;
Tap.spacedBuffFactor = 0.10;
Tap.decayCoeffs = new Vector_1.Vector(MathNet_1.MathNet.LinearSpaced(4, 2.3, -2.2)).PointwiseExp();
exports.default = Tap;
