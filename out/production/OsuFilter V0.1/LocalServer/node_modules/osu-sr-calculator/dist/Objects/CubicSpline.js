"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("../Utils");
class CubicSpline {
    // private readonly  _indefiniteIntegral: number[];
    constructor(x, c0, c1, c2, c3) {
        if (x.length !== c0.length + 1 || x.length !== c1.length + 1 || x.length !== c2.length + 1 || x.length !== c3.length + 1)
            throw new Error('CubicSpline: arguments same length');
        if (x.length < 2)
            throw new Error('CubicSpline: array x too small');
        this._x = x;
        this._c0 = c0;
        this._c1 = c1;
        this._c2 = c2;
        this._c3 = c3;
        // this._indefiniteIntegral = this.ComputeIndefiniteIntegral();
    }
    getValues() {
        return [this._x, this._c0, this._c1, this._c2, this._c3];
    }
    static InterpolateHermiteSorted(x, y, firstDerivatives) {
        if (x.length !== y.length || x.length !== firstDerivatives.length)
            throw new Error('CubicSpline InterpolateHermiteSorted: arguments same length');
        if (x.length < 2)
            throw new Error('CubicSpline InterpolateHermiteSorted: array x too small');
        const c0 = Utils_1.default.initializeArray(x.length - 1);
        const c1 = Utils_1.default.initializeArray(x.length - 1);
        const c2 = Utils_1.default.initializeArray(x.length - 1);
        const c3 = Utils_1.default.initializeArray(x.length - 1);
        for (let i = 0; i < c1.length; i++) {
            const w = x[i + 1] - x[i];
            const w2 = w * w;
            c0[i] = y[i];
            c1[i] = firstDerivatives[i];
            c2[i] = (3 * (y[i + 1] - y[i]) / w - 2 * firstDerivatives[i] - firstDerivatives[i + 1]) / w;
            c3[i] = (2 * (y[i] - y[i + 1]) / w + firstDerivatives[i] + firstDerivatives[i + 1]) / w2;
        }
        return new CubicSpline(x, c0, c1, c2, c3);
    }
    Interpolate(t) {
        const k = this.LeftSegmentIndex(t);
        const x = t - this._x[k];
        return this._c0[k] + x * (this._c1[k] + x * (this._c2[k] + x * this._c3[k]));
    }
    // private ComputeIndefiniteIntegral(): number[] {
    //     const integral = Utils.initializeArray(this._c1.length);
    //     for (let i = 0; i < integral.length; i++) {
    //         const w = this._x[i + 1] - this._x[i];
    //         integral[i + 1] = integral[i] + w * (this._c0[i] + w * (this._c1[i] / 2 + w * (this._c2[i] / 3 + w * this._c3[i] / 4)));
    //     }
    //     return integral;
    // }
    LeftSegmentIndex(t) {
        let index;
        for (let i = 0; i < this._x.length; i++) {
            const value = this._x[i];
            if (value === t) {
                index = i;
                break;
            }
            if (value > t) {
                index = ~i;
                break;
            }
        }
        if (index === undefined)
            index = ~this._x.length;
        if (index < 0)
            index = ~index - 1;
        return Math.min(Math.max(index, 0), this._x.length - 2);
    }
}
exports.CubicSpline = CubicSpline;
