"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Vector {
    constructor(values) {
        this.values = values;
    }
    getValue(index) {
        if (index >= this.values.length)
            throw new Error('Vector getValue: Index out of range!');
        return this.values[index];
    }
    setValue(index, value) {
        if (index >= this.values.length)
            throw new Error('Vector getValue: Index out of range!');
        this.values[index] = value;
    }
    PointwiseExp() {
        return new Vector(this.values.map(v => Math.pow(Math.E, v)));
    }
    add(other) {
        return new Vector(this.values.map((v, index) => v + other.getValue(index)));
    }
    subtract(other) {
        return new Vector(this.values.map((v, index) => v - other.getValue(index)));
    }
    subtractScalar(scalar) {
        return new Vector(this.values.map(v => v - scalar));
    }
    multiply(factor) {
        return new Vector(this.values.map(v => v * factor));
    }
    divide(divider) {
        if (divider === 0)
            throw new Error('Vector divide: tried to divide by 0!');
        return new Vector(this.values.map(v => v / divider));
    }
    PointwiseMultiply(other) {
        const result = this.values.map((v, index) => v * other.getValue(index));
        // if (result.includes(NaN))
        //     console.log('this:', this.values, '; other:', other.values);
        return new Vector(result);
    }
    negate() {
        return new Vector(this.values.map(v => -v));
    }
    PointwisePower(power) {
        return new Vector(this.values.map(v => Math.pow(v, power)));
    }
    L2Norm() {
        return Math.sqrt(this.values.reduce((total, current) => total + Math.pow(current, 2), 0));
    }
    DotProduct(other) {
        return this.values.reduce((total, current, index) => total + (current * other.getValue(index)), 0);
    }
    Count() {
        return this.values.length;
    }
}
exports.Vector = Vector;
