"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SliderEventType_1 = require("./Objects/osu!/HitObjects/SliderObjects/SliderEventType");
class SliderEventGenerator {
    static Generate(startTime, spanDuration, velocity, tickDistance, totalDistance, spanCount, legacyLastTickOffset) {
        const SliderEvents = [];
        const max_length = 100000;
        const length = Math.min(max_length, totalDistance);
        tickDistance = Math.min(Math.max(tickDistance, 0), length);
        const minDistanceFromEnd = velocity * 10;
        SliderEvents.push({
            Type: SliderEventType_1.SliderEventType.Head,
            SpanIndex: 0,
            SpanStartTime: startTime,
            Time: startTime,
            PathProgress: 0
        });
        if (tickDistance !== 0) {
            for (let span = 0; span < spanCount; span++) {
                const spanStartTime = startTime + span * spanDuration;
                const reversed = span % 2 === 1;
                let ticks = this.generateTicks(span, spanStartTime, spanDuration, reversed, length, tickDistance, minDistanceFromEnd);
                if (reversed)
                    ticks = ticks.reverse();
                ticks.forEach(e => {
                    SliderEvents.push(e);
                });
                if (span < spanCount - 1) {
                    SliderEvents.push({
                        Type: SliderEventType_1.SliderEventType.Repeat,
                        SpanIndex: span,
                        SpanStartTime: startTime + span * spanDuration,
                        Time: spanStartTime + spanDuration,
                        PathProgress: (span + 1) % 2
                    });
                }
            }
        }
        const totalDuration = spanCount * spanDuration;
        const finalSpanIndex = spanCount - 1;
        const finalSpanStartTime = startTime + finalSpanIndex * spanDuration;
        const finalSpanEndTime = Math.max(startTime + totalDuration / 2, (finalSpanStartTime + spanDuration) - (legacyLastTickOffset || 0));
        let finalProgress = (finalSpanEndTime - finalSpanStartTime) / spanDuration;
        if (spanCount % 2 === 0)
            finalProgress = 1 - finalProgress;
        SliderEvents.push({
            Type: SliderEventType_1.SliderEventType.LegacyLastTick,
            SpanIndex: finalSpanIndex,
            SpanStartTime: finalSpanStartTime,
            Time: finalSpanEndTime,
            PathProgress: finalProgress
        });
        SliderEvents.push({
            Type: SliderEventType_1.SliderEventType.Tail,
            SpanIndex: finalSpanIndex,
            SpanStartTime: startTime + (spanCount - 1) * spanDuration,
            Time: startTime + totalDuration,
            PathProgress: spanCount % 2
        });
        return SliderEvents;
    }
    static generateTicks(spanIndex, spanStartTime, spanDuration, reversed, length, tickDistance, minDistanceFromEnd) {
        const Ticks = [];
        for (let d = tickDistance; d <= length; d += tickDistance) {
            if (d >= length - minDistanceFromEnd)
                break;
            const pathProgress = d / length;
            const timeProgress = reversed ? 1 - pathProgress : pathProgress;
            Ticks.push({
                Type: SliderEventType_1.SliderEventType.Tick,
                SpanIndex: spanIndex,
                SpanStartTime: spanStartTime,
                Time: spanStartTime + timeProgress * spanDuration,
                PathProgress: pathProgress
            });
        }
        return Ticks;
    }
}
exports.default = SliderEventGenerator;
