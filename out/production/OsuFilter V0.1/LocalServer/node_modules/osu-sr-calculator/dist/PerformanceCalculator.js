"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HitCircle_1 = require("./Objects/osu!/HitObjects/HitCircle");
const Slider_1 = require("./Objects/osu!/HitObjects/Slider");
const AttributesGenerator_1 = require("./AttributesGenerator");
const MathNet_1 = require("./MathNet");
const LinearSpline_1 = require("./Objects/LinearSpline");
const Utils_1 = require("./Utils");
const mathfn = require('mathfn');
class PerformanceCalculator {
    constructor() {
        this.totalValueExponent = 1.5;
        this.comboWeight = 0.5;
        this.skillToPPExponent = 2.7;
    }
    calculate(beatmap, score, clockRate) {
        this.Attributes = AttributesGenerator_1.default.Calculate(beatmap, score.mods, clockRate);
        // console.log('Attributes:', this.Attributes);
        this.countHitCircles = beatmap.HitObjects.filter(o => o instanceof HitCircle_1.HitCircle).length;
        this.countSliders = beatmap.HitObjects.filter(o => o instanceof Slider_1.Slider).length;
        this.beatmapMaxCombo = beatmap.HitObjects.length;
        // console.log(`hitObjects length: ${beatmap.HitObjects.length}`);
        this.beatmapMaxCombo += beatmap.HitObjects.filter(o => o instanceof Slider_1.Slider).reduce((total, current) => total + current.NestedHitObjects.length - 1, 0);
        // beatmap.HitObjects.filter(o => o instanceof Slider).forEach((s: Slider)=> {
        //     console.log(s.NestedHitObjects.length)
        // });
        this.mods = score.mods;
        this.accuracy = score.accuracy;
        this.scoreMaxCombo = score.maxCombo;
        this.countGreat = score.statistics.great;
        this.countGood = score.statistics.good;
        this.countMeh = score.statistics.meh;
        this.countMiss = score.statistics.miss;
        this.totalHits = this.countGreat + this.countGood + this.countMeh + this.countMiss;
        this.greatWindow = 79.5 - 6 * beatmap.OverallDifficulty;
        //Don't count unranked mods
        let multiplier = 2.14;
        if (this.mods.includes('NF'))
            multiplier *= 0.9;
        if (this.mods.includes('SO'))
            multiplier *= 0.95;
        const aimValue = this.calculateAimValue();
        const tapValue = this.calculateTapValue();
        const accuracyValue = this.calculateAccuracyValue();
        // console.log(`aim: ${aimValue}; tap: ${tapValue}; accuracy: ${accuracyValue}`);
        const totalValue = Utils_1.default.PowerMean([aimValue, tapValue, accuracyValue], this.totalValueExponent) * multiplier;
        return totalValue;
    }
    calculateAimValue() {
        const effectiveMissCount = Math.max(this.countMiss, Math.floor((this.beatmapMaxCombo - 0.1 * this.countSliders) / this.scoreMaxCombo));
        // console.log(`effectiveMissCount: ${effectiveMissCount}`);
        const comboTPCount = this.Attributes.ComboTPs.length;
        // console.log(`comboTPCount: ${comboTPCount}`);
        const comboPercentages = MathNet_1.MathNet.LinearSpaced(comboTPCount, 1 / comboTPCount, 1);
        // console.log(`comboPercentages: ${comboPercentages}`);
        const scoreComboPercentage = this.scoreMaxCombo / this.beatmapMaxCombo;
        // console.log(`scoreMaxCombo: ${this.scoreMaxCombo}`);
        // console.log(`beatmapMaxCombo: ${this.beatmapMaxCombo}`);
        // console.log(`scoreComboPercentage: ${scoreComboPercentage}`);
        const comboTP = LinearSpline_1.LinearSpline.InterpolateSorted(comboPercentages, this.Attributes.ComboTPs).Interpolate(scoreComboPercentage);
        // console.log(`comboTP: ${comboTP}`);
        let missTP;
        if (effectiveMissCount === 0)
            missTP = this.Attributes.MissTPs[0];
        else {
            missTP = LinearSpline_1.LinearSpline.InterpolateSorted(this.Attributes.MissCounts, this.Attributes.MissTPs).Interpolate(effectiveMissCount);
            missTP = Math.max(missTP, 0);
        }
        // console.log(`missTP: ${missTP}`);
        let tp = Math.pow(comboTP, this.comboWeight) * Math.pow(missTP, 1 - this.comboWeight);
        // console.log(`tp: ${tp}`);
        const modifiedAcc = this.getModifiedAcc();
        // console.log(`modifiedAcc: ${modifiedAcc}`);
        const accOnCheeseNotes = 1 - (1 - modifiedAcc) * Math.sqrt(this.totalHits / this.Attributes.CheeseNoteCount);
        const accOnCheeseNotesPositive = Math.exp(accOnCheeseNotes - 1);
        // console.log(`accOnCheeseNotesPositive: ${accOnCheeseNotesPositive}`);
        const urOnCheeseNotes = 10 * this.greatWindow / (Math.sqrt(2) * mathfn.invErf(accOnCheeseNotesPositive));
        // console.log(`urOnCheeseNotes: ${urOnCheeseNotes}`);
        const cheeseLevel = MathNet_1.MathNet.Logistic(((urOnCheeseNotes * this.Attributes.AimDiff) - 4300) / 2000);
        // console.log(`cheeseLevel: ${cheeseLevel}`);
        const cheeseFactor = LinearSpline_1.LinearSpline.InterpolateSorted(this.Attributes.CheeseLevels, this.Attributes.CheeseFactors).Interpolate(cheeseLevel);
        // console.log(`cheeseFactor: ${cheeseFactor}`);
        if (this.mods.includes('Touch Device') || this.mods.includes('TouchDevice') || this.mods.includes('TD'))
            tp = Math.min(tp, 1.47 * Math.pow(tp, 0.8));
        let aimValue = this.tpToPP(tp * cheeseFactor);
        aimValue *= Math.pow(0.96, effectiveMissCount);
        // console.log(`aimValue: ${aimValue}`);
        let approachRateFactor = 1;
        const ar11lengthBuff = 0.8 * (MathNet_1.MathNet.Logistic(this.totalHits / 500) - 0.5);
        if (this.Attributes.ApproachRate > 10.33)
            approachRateFactor += (ar11lengthBuff * (this.Attributes.ApproachRate - 10.33) / 0.67);
        else if (this.Attributes.ApproachRate < 8)
            approachRateFactor += (0.01 * (8 - this.Attributes.ApproachRate));
        // console.log(`approach rate: ${this.Attributes.ApproachRate}`);
        aimValue *= approachRateFactor;
        // console.log(`approachRateFactor: ${approachRateFactor}`);
        if (this.mods.includes('HD'))
            aimValue *= (1 + 0.04 * (12 - this.Attributes.ApproachRate));
        if (this.mods.includes('FL'))
            aimValue *= (1 + 0.35 * Math.min(1, this.totalHits / 200) + (this.totalHits > 200
                ? 0.3 * Math.min(1, (this.totalHits - 200) / 300) + (this.totalHits > 500 ? (this.totalHits - 500) / 2000 : 0)
                : 0));
        const accLeniency = this.greatWindow * this.Attributes.AimDiff / 300;
        // console.log(`accLeniency: ${accLeniency}`);
        const accPenalty = (0.09 / (this.accuracy - 1.3) + 0.3) * (accLeniency + 1.5);
        // console.log(`accPenalty: ${accPenalty}`);
        aimValue *= Math.exp(-accPenalty);
        return aimValue;
    }
    calculateTapValue() {
        const modifiedAcc = this.getModifiedAcc();
        const accOnStreams = 1 - (1 - modifiedAcc) * Math.sqrt(this.totalHits / this.Attributes.StreamNoteCount);
        const accOnStreamsPositive = Math.exp(accOnStreams - 1);
        const urOnStreams = 10 * this.greatWindow / (Math.sqrt(2) * mathfn.invErf(accOnStreamsPositive));
        const mashLevel = MathNet_1.MathNet.Logistic(((urOnStreams * this.Attributes.TapDiff) - 4000) / 1000);
        const tapSkill = LinearSpline_1.LinearSpline.InterpolateSorted(this.Attributes.MashLevels, this.Attributes.TapSkills).Interpolate(mashLevel);
        let tapValue = this.tapSkillToPP(tapSkill);
        const accBuff = Math.exp((accOnStreams - 1) * 60) * tapValue * 0.2;
        tapValue += accBuff;
        const accFactor = 0.5 + 0.5 * (MathNet_1.MathNet.Logistic((this.accuracy - 0.65) / 0.1) + MathNet_1.MathNet.Logistic(-3.5));
        tapValue *= accFactor;
        tapValue *= Math.pow(0.93, this.countMiss);
        tapValue *= Math.pow(0.98, this.countMeh);
        let approachRateFactor = 1;
        const ar11lengthBuff = 0.8 * (MathNet_1.MathNet.Logistic(this.totalHits / 500) - 0.5);
        if (this.Attributes.ApproachRate > 10.33)
            approachRateFactor += (ar11lengthBuff * (this.Attributes.ApproachRate - 10.33) / 0.67);
        tapValue *= approachRateFactor;
        return tapValue;
    }
    calculateAccuracyValue() {
        const fingerControlDiff = this.Attributes.FingerControlDiff;
        // console.log(`fingerControlDiff: ${fingerControlDiff}`);
        const modifiedAcc = this.getModifiedAcc();
        // console.log(`modifiedAcc: ${modifiedAcc}`);
        const accOnCircles = modifiedAcc - 0.003;
        const accOnCirclesPositive = Math.exp(accOnCircles - 1);
        // console.log(`accOnCirclesPositive: ${accOnCirclesPositive}`);
        const deviationOnCircles = (this.greatWindow + 20) / (Math.sqrt(2) * mathfn.invErf(accOnCirclesPositive));
        // console.log(`deviationOnCircles: ${deviationOnCircles}`);
        // console.log(`greatWindow: ${this.greatWindow}`)
        let accuracyValue = Math.pow(deviationOnCircles, -2.2) * Math.pow(fingerControlDiff, 0.5) * 46000;
        // console.log(`accuracyValue: ${accuracyValue}`);
        const lengthFactor = MathNet_1.MathNet.Logistic(this.Attributes.Length / 60);
        // console.log(`lengthFactor: ${lengthFactor}`);
        accuracyValue *= lengthFactor;
        if (this.mods.includes('HD'))
            accuracyValue *= 1.08;
        if (this.mods.includes('FL'))
            accuracyValue *= 1.02;
        return accuracyValue;
    }
    getModifiedAcc() {
        // console.log(`countGreat: ${this.countGreat}`);
        // console.log(`countGood: ${this.countGood}`);
        // console.log(`countMeh: ${this.countMeh}`);
        // console.log(`totalHits: ${this.totalHits}`);
        // console.log(`countHitCircles: ${this.countHitCircles}`);
        return ((this.countGreat - (this.totalHits - this.countHitCircles)) * 3 + this.countGood * 2 + this.countMeh) / ((this.countHitCircles + 2) * 3);
    }
    tpToPP(tp) {
        // console.log(`tp: ${tp}`);
        // console.log(`skillToPPExponent: ${this.skillToPPExponent}`);
        return Math.pow(tp, this.skillToPPExponent) * 0.126;
    }
    tapSkillToPP(tapSkill) {
        return Math.pow(tapSkill, this.skillToPPExponent) * 0.115;
    }
}
exports.default = PerformanceCalculator;
